// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "LevelSequence.h"
#include "LevelSequencePlayer.h"
#include "LevelSequenceActor.h"
#include "CineCameraActor.h"
#include "AIDM/CampaignLoaderSubsystem.h"
#include "Narrative/NarrativeMemoryComponent.h"
#include "Audio/VoiceSynthesisComponent.h"
#include "ProceduralCutsceneGenerator.generated.h"

/**
 * Cutscene types
 */
UENUM(BlueprintType)
enum class ECutsceneType : uint8
{
    Dialogue        UMETA(DisplayName = "Dialogue Scene"),
    Action          UMETA(DisplayName = "Action Sequence"),
    Revelation      UMETA(DisplayName = "Story Revelation"),
    Emotional       UMETA(DisplayName = "Emotional Moment"),
    Transition      UMETA(DisplayName = "Transition"),
    Flashback       UMETA(DisplayName = "Flashback"),
    Vision          UMETA(DisplayName = "Force Vision"),
    Combat          UMETA(DisplayName = "Combat Cinematic"),
    Death           UMETA(DisplayName = "Death Scene"),
    Victory         UMETA(DisplayName = "Victory Celebration")
};

/**
 * Camera shot types
 */
UENUM(BlueprintType)
enum class ECameraShotType : uint8
{
    CloseUp         UMETA(DisplayName = "Close-Up"),
    MediumShot      UMETA(DisplayName = "Medium Shot"),
    WideShot        UMETA(DisplayName = "Wide Shot"),
    OverShoulder    UMETA(DisplayName = "Over-the-Shoulder"),
    Tracking        UMETA(DisplayName = "Tracking Shot"),
    Dolly           UMETA(DisplayName = "Dolly Shot"),
    Crane           UMETA(DisplayName = "Crane Shot"),
    Handheld        UMETA(DisplayName = "Handheld"),
    Establishing    UMETA(DisplayName = "Establishing Shot"),
    Reaction        UMETA(DisplayName = "Reaction Shot")
};

/**
 * Camera shot data
 */
USTRUCT(BlueprintType)
struct KOTOR_CLONE_API FProceduralCameraShot
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    FString ShotID;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    ECameraShotType ShotType;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    FVector StartLocation;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    FRotator StartRotation;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    FVector EndLocation;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    FRotator EndRotation;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    float Duration;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    AActor* FocusTarget;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    float FOV;

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    FString TransitionType; // "cut", "fade", "dissolve", "wipe"

    UPROPERTY(BlueprintReadWrite, Category = "Camera Shot")
    TMap<FString, float> CameraSettings; // Additional camera parameters

    FProceduralCameraShot()
    {
        ShotID = TEXT("");
        ShotType = ECameraShotType::MediumShot;
        StartLocation = FVector::ZeroVector;
        StartRotation = FRotator::ZeroRotator;
        EndLocation = FVector::ZeroVector;
        EndRotation = FRotator::ZeroRotator;
        Duration = 3.0f;
        FocusTarget = nullptr;
        FOV = 90.0f;
        TransitionType = TEXT("cut");
    }
};

/**
 * Cutscene generation parameters
 */
USTRUCT(BlueprintType)
struct KOTOR_CLONE_API FCutsceneGenerationParams
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    ECutsceneType CutsceneType;

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    FString SceneContext; // Context for the cutscene

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    TArray<FString> ParticipantNPCs; // NPCs involved

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    FString Location; // Where cutscene takes place

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    float TargetDuration; // Desired duration in seconds

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    FString EmotionalTone; // "tense", "sad", "triumphant", etc.

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    TArray<FString> DialogueLines; // Pre-written dialogue (optional)

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    bool bUseVoiceSynthesis; // Whether to generate voice

    UPROPERTY(BlueprintReadWrite, Category = "Cutscene Generation")
    bool bAutoGenerateDialogue; // Whether to generate dialogue

    FCutsceneGenerationParams()
    {
        CutsceneType = ECutsceneType::Dialogue;
        SceneContext = TEXT("");
        Location = TEXT("");
        TargetDuration = 30.0f;
        EmotionalTone = TEXT("neutral");
        bUseVoiceSynthesis = true;
        bAutoGenerateDialogue = true;
    }
};

/**
 * Generated cutscene data
 */
USTRUCT(BlueprintType)
struct KOTOR_CLONE_API FGeneratedCutscene
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    FString CutsceneID;

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    ECutsceneType Type;

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    FString Title;

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    FString Description;

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    TArray<FProceduralCameraShot> CameraShots;

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    TArray<FString> DialogueLines;

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    TArray<FString> Speakers; // Who speaks each line

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    TArray<FString> CharacterAnimations; // Animation sequences

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    FString MusicTrack; // Background music

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    TArray<FString> SoundEffects; // Sound effects

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    float TotalDuration;

    UPROPERTY(BlueprintReadWrite, Category = "Generated Cutscene")
    bool bIsGenerated; // Whether this was procedurally generated

    FGeneratedCutscene()
    {
        CutsceneID = TEXT("");
        Type = ECutsceneType::Dialogue;
        Title = TEXT("Generated Cutscene");
        Description = TEXT("");
        MusicTrack = TEXT("");
        TotalDuration = 0.0f;
        bIsGenerated = true;
    }
};

/**
 * Cutscene events
 */
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCutsceneGenerated, const FGeneratedCutscene&, Cutscene);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCutsceneStarted, const FGeneratedCutscene&, Cutscene);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCutsceneCompleted, const FGeneratedCutscene&, Cutscene);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnCameraShotChanged, const FProceduralCameraShot&, OldShot, const FProceduralCameraShot&, NewShot);

/**
 * Procedural Cutscene Generator - Creates dynamic cinematics with LLM integration
 */
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent), BlueprintType, Blueprintable)
class KOTOR_CLONE_API UProceduralCutsceneGenerator : public UActorComponent
{
    GENERATED_BODY()

public:
    UProceduralCutsceneGenerator();

protected:
    virtual void BeginPlay() override;
    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

public:
    /**
     * Initialize cutscene generator
     * @param CampaignLoader Campaign loader for context
     * @param NarrativeMemory Narrative memory for story context
     * @param VoiceSynthesis Voice synthesis for dialogue
     */
    UFUNCTION(BlueprintCallable, Category = "Procedural Cutscenes")
    void InitializeCutsceneGenerator(UCampaignLoaderSubsystem* CampaignLoader,
                                    UNarrativeMemoryComponent* NarrativeMemory,
                                    UVoiceSynthesisComponent* VoiceSynthesis);

    /**
     * Generate cutscene from parameters
     * @param GenerationParams Parameters for cutscene generation
     * @return Generated cutscene data
     */
    UFUNCTION(BlueprintCallable, Category = "Procedural Cutscenes")
    FGeneratedCutscene GenerateCutscene(const FCutsceneGenerationParams& GenerationParams);

    /**
     * Generate cutscene from context
     * @param CutsceneType Type of cutscene to generate
     * @param Context Contextual information
     * @param Participants NPCs involved
     * @return Generated cutscene data
     */
    UFUNCTION(BlueprintCallable, Category = "Procedural Cutscenes")
    FGeneratedCutscene GenerateCutsceneFromContext(ECutsceneType CutsceneType, 
                                                  const FString& Context, 
                                                  const TArray<FString>& Participants);

    /**
     * Play generated cutscene
     * @param CutsceneID ID of cutscene to play
     * @return True if cutscene started successfully
     */
    UFUNCTION(BlueprintCallable, Category = "Procedural Cutscenes")
    bool PlayGeneratedCutscene(const FString& CutsceneID);

    /**
     * Stop current cutscene
     */
    UFUNCTION(BlueprintCallable, Category = "Procedural Cutscenes")
    void StopCurrentCutscene();

    /**
     * Generate camera shots for scene
     * @param CutsceneType Type of cutscene
     * @param Participants NPCs in the scene
     * @param Duration Target duration
     * @return Array of generated camera shots
     */
    UFUNCTION(BlueprintCallable, Category = "Procedural Cutscenes")
    TArray<FProceduralCameraShot> GenerateCameraShots(ECutsceneType CutsceneType, 
                                                     const TArray<FString>& Participants, 
                                                     float Duration);

    /**
     * Generate dialogue for cutscene
     * @param CutsceneType Type of cutscene
     * @param Context Scene context
     * @param Participants NPCs involved
     * @return Generated dialogue lines
     */
    UFUNCTION(BlueprintCallable, Category = "Procedural Cutscenes")
    TArray<FString> GenerateDialogue(ECutsceneType CutsceneType, 
                                    const FString& Context, 
                                    const TArray<FString>& Participants);

    /**
     * Get generated cutscene by ID
     * @param CutsceneID ID of the cutscene
     * @return Cutscene data
     */
    UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Procedural Cutscenes")
    FGeneratedCutscene GetGeneratedCutscene(const FString& CutsceneID) const;

    /**
     * Get all generated cutscenes
     * @return Array of all generated cutscenes
     */
    UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Procedural Cutscenes")
    TArray<FGeneratedCutscene> GetAllGeneratedCutscenes() const { return GeneratedCutscenes; }

    /**
     * Check if cutscene is playing
     * @return True if a cutscene is currently playing
     */
    UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Procedural Cutscenes")
    bool IsCutscenePlaying() const { return bCutscenePlaying; }

    /**
     * Get current cutscene progress (0.0 to 1.0)
     * @return Current playback progress
     */
    UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Procedural Cutscenes")
    float GetCutsceneProgress() const;

    /**
     * Export cutscene to sequence asset
     * @param CutsceneID ID of cutscene to export
     * @param AssetPath Path to save the sequence asset
     * @return True if export was successful
     */
    UFUNCTION(BlueprintCallable, Category = "Procedural Cutscenes")
    bool ExportCutsceneToSequence(const FString& CutsceneID, const FString& AssetPath);

    // Event delegates
    UPROPERTY(BlueprintAssignable, Category = "Cutscene Events")
    FOnCutsceneGenerated OnCutsceneGenerated;

    UPROPERTY(BlueprintAssignable, Category = "Cutscene Events")
    FOnCutsceneStarted OnCutsceneStarted;

    UPROPERTY(BlueprintAssignable, Category = "Cutscene Events")
    FOnCutsceneCompleted OnCutsceneCompleted;

    UPROPERTY(BlueprintAssignable, Category = "Cutscene Events")
    FOnCameraShotChanged OnCameraShotChanged;

protected:
    // Generated cutscenes
    UPROPERTY(BlueprintReadOnly, Category = "Procedural Cutscenes")
    TArray<FGeneratedCutscene> GeneratedCutscenes;

    // Current playback state
    UPROPERTY(BlueprintReadOnly, Category = "Procedural Cutscenes")
    bool bCutscenePlaying;

    UPROPERTY(BlueprintReadOnly, Category = "Procedural Cutscenes")
    FGeneratedCutscene CurrentCutscene;

    UPROPERTY(BlueprintReadOnly, Category = "Procedural Cutscenes")
    int32 CurrentShotIndex;

    UPROPERTY(BlueprintReadOnly, Category = "Procedural Cutscenes")
    int32 CurrentDialogueIndex;

    UPROPERTY(BlueprintReadOnly, Category = "Procedural Cutscenes")
    float CutsceneStartTime;

    // Component references
    UPROPERTY()
    UCampaignLoaderSubsystem* CampaignLoaderRef;

    UPROPERTY()
    UNarrativeMemoryComponent* NarrativeMemoryRef;

    UPROPERTY()
    UVoiceSynthesisComponent* VoiceSynthesisRef;

    // Sequence player
    UPROPERTY()
    ALevelSequenceActor* SequenceActor;

    UPROPERTY()
    ULevelSequencePlayer* SequencePlayer;

    // Camera management
    UPROPERTY()
    ACineCameraActor* CutsceneCamera;

    UPROPERTY()
    AActor* OriginalViewTarget;

    // Generation templates
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Generation Templates")
    TMap<ECutsceneType, TArray<FString>> CutsceneTemplates;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Generation Templates")
    TMap<ECameraShotType, FProceduralCameraShot> ShotTemplates;

    // LLM prompts
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "LLM Prompts")
    FString DialoguePromptTemplate;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "LLM Prompts")
    FString CameraPromptTemplate;

    // Timer handles
    FTimerHandle ShotTimer;
    FTimerHandle DialogueTimer;

private:
    // Helper methods
    void LoadCutsceneTemplates();
    void LoadShotTemplates();
    FString GenerateCutsceneID();
    FString GenerateShotID();
    void PlayNextShot();
    void PlayNextDialogueLine();
    void CompleteCutscene();
    FProceduralCameraShot GenerateShotForType(ECameraShotType ShotType, const TArray<AActor*>& Targets);
    FVector CalculateCameraPosition(ECameraShotType ShotType, AActor* Target);
    FRotator CalculateCameraRotation(const FVector& CameraPos, AActor* Target);

public:
    /**
     * Blueprint implementable events for custom cutscene logic
     */

    /**
     * Called when cutscene is generated (for custom processing)
     * @param Cutscene The generated cutscene
     */
    UFUNCTION(BlueprintImplementableEvent, Category = "Cutscene Events")
    void OnCutsceneGeneratedEvent(const FGeneratedCutscene& Cutscene);

    /**
     * Called when cutscene starts (for custom setup)
     * @param Cutscene The starting cutscene
     */
    UFUNCTION(BlueprintImplementableEvent, Category = "Cutscene Events")
    void OnCutsceneStartedEvent(const FGeneratedCutscene& Cutscene);

    /**
     * Called to generate custom dialogue (override in Blueprint)
     * @param GenerationParams Cutscene generation parameters
     * @return Custom generated dialogue
     */
    UFUNCTION(BlueprintImplementableEvent, Category = "Cutscene Events")
    TArray<FString> GenerateCustomDialogue(const FCutsceneGenerationParams& GenerationParams);

    /**
     * Called to generate custom camera shots (override in Blueprint)
     * @param GenerationParams Cutscene generation parameters
     * @return Custom generated camera shots
     */
    UFUNCTION(BlueprintImplementableEvent, Category = "Cutscene Events")
    TArray<FProceduralCameraShot> GenerateCustomCameraShots(const FCutsceneGenerationParams& GenerationParams);
};
